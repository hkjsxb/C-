## 处理类型

[TOC]

---



#####  类型别名

> -    typedef    double a;
>
>   其中 typedef为 用于定义类型别名 ， double 为类型修饰 ，a 为类型别名
>
>   -    double b   ；       //a==double;
>
>   -   a  c;
>   - //c==b;   其中    a 和 double 为类型修饰，b和c 为变量名称 ，都是double型
>
> - 新标准规定了一种新的方法，使用别名声明来定义类型的别名：
>
>   > - - using SI=n;      //SI是n的同义词，其作用是把等号左侧的名字规定成等号右侧的别名
>
> - 指针、变量和类型别名
>
>   - ```
>     typedef  char  *pstring;    //pstring      实际上是类型char*的别名；
>     const pstring cstr=0;  //cstr是指向char的常量指针
>     const psring *ps;      //ps是一个指针，它的对象是指向char的常量指针
>     ```



##### auto类型说明符

> -   auto定义的变量必须有初始值；
>
>   -    //由val 1 and val2 相加的结果可以推断出item的类型
>
>   - ```
>     auto item =val1+val2;//item初始化为val1和val2相加的结果
>     ```
>
> - 使用auto也可以定义多个变量，所有变量的初始基本数据类型都必须一样：
>   -  auto   i=0,  *p  =  &i  ;    //   i 是整数，p 是整型指针
>   - auto    sz=0 ,  pi=3.14    //错误： sz和pi的类型不一致
>
> -  复合类型 、常量和auto
>
>   - 
>
>     ```
>     int i=0，&r=i;
>     auto a=r;// a 是一个整数（r是a的别名，而i是一个整数）
>     ```
>
>   - auto一般会忽略顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：
>
>   - ```
>     const int ci=i, &cr=ci;
>     auto b=ci; // b是一个整数（ci的顶层const特性被忽略了）
>     auto c=cr; // c是一个整数（cr=ci的别名，ci本身是一个顶层const）
>     auto d=&i; // d是一个整型指针（整数的地址就是指向整数的指针）
>     auto e=&ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层const）
>     ```
>
>     
>
>   - 保留顶层const
>
>     ```
>     const auto f=ci;//ci的推演类型为int ，f是const in
>     ```
>
>   - 引用的类型设为auto
>
>     ```
>     auto &g=ci;//g是一个整数常量引用，绑定到ci
>     auto &h=42;//错误：不能为非常量引用绑定字面值
>     const auto &j=42;//正确：可以为常量引用绑定字面值
>     ```
>
>   - ```
>     auto k=ci,&l=i;//k是整数，l是整数引用
>     auto &m=ci,*p=&ci;//m是对整型常量的引用，p是指向整型常量的指针
>     ```
>
>     
>
> - 例题
>
>   - ```
>     const int i=42;  //i为整型常量
>     auto j=i;        //j去掉了i的顶层const特性，为整数42
>     const auto &k=i; //k为常量引用绑定i
>     auto *p=&i;       //p是指向整型常量的指针
>     const auto j2=i,&k2=i;  //i的推演类型为int，j2是const in，k2为常量引用绑定到字面值
>     ```
>
>     